using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Noggog;

namespace MusicFixer
{
    public class Program
    {
        static Lazy<Settings> Settings = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "MusicFixer.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (Settings.Value.TargetMods.Count == 0)
            {
                System.Console.WriteLine("Must at least specify one target mod in order to do anything.");
                return;
            }

            var targetMods = state.LoadOrder.ListedOrder
                .Select(listing => listing.Mod)
                .NotNull()
                .Where(plugin => Settings.Value.TargetMods.Contains(plugin.ModKey))
                .ToArray();

            System.Console.WriteLine("Files to map to:");
            foreach (var modKey in targetMods.Select(x => x.ModKey))
            {
                System.Console.WriteLine($"  {modKey}");
            }

            var loadOrderLinkCache = state.LoadOrder.ToImmutableLinkCache();
            var targetModsLinkCache = targetMods.ToImmutableLinkCache();

            uint cellsPatched = 0;
            // Loop through winning cell records (with context) in load order
            foreach (var winningCellContext in state.LoadOrder.PriorityOrder.Cell().WinningContextOverrides(loadOrderLinkCache))
            {
                // See if the cell is in the target mods(s). If it is, retrieve the version of the cell record from the target mod.
                if (targetModsLinkCache.TryResolve<ICellGetter>(winningCellContext.Record.FormKey, out var targetCellRecord)) {
                    // Check if the record has been modified by the target mod(s)
                    if (!targetCellRecord.Music.Equals(winningCellContext.Record.Music))
                    {
                        // Add the winning record to the patch
                        var patchRecord = winningCellContext.GetOrAddAsOverride(state.PatchMod);
                        patchRecord.Music.FormKey = targetCellRecord.Music.FormKey;

                        cellsPatched++;
                    }
                };
            };

            uint worldspacesPatched = 0;
            // Loop through winning worldspace records (with context) in load order
            foreach (var winningWorldspaceContext in state.LoadOrder.PriorityOrder.Worldspace().WinningContextOverrides())
            {
                // See if the worldspace is in the target mods(s). If it is, retrieve the version of the worldspace record from the target mod.
                if (targetModsLinkCache.TryResolve<IWorldspaceGetter>(winningWorldspaceContext.Record.FormKey, out var targetWorldspaceRecord)) {
                    // Check if the record has been modified by the target mod(s)
                    if (!targetWorldspaceRecord.Music.Equals(winningWorldspaceContext.Record.Music))
                    {
                        // Add the winning record to the patch
                        var patchRecord = winningWorldspaceContext.GetOrAddAsOverride(state.PatchMod);
                        patchRecord.Music.FormKey = targetWorldspaceRecord.Music.FormKey;

                        worldspacesPatched++;
                    }
                };
            };

            Console.WriteLine($"Finished patching {cellsPatched} cellsPatched");
            Console.WriteLine($"Finished patching {worldspacesPatched} worldspaces");
            Console.WriteLine();
        }
    }
}
